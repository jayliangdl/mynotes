# 问题与方案

### 1\. 太阳码问题

- **_问题描述：_**

电商系统中有一个顾客分享产品的场景，需要依赖腾讯提供的太阳码API为顾客产生太阳码，太阳码实质是一个URL，上面带着一些参数（包括顾客编号、顾客选择的产品等）。当顾客分享给其他朋友后，朋友通过扫描太阳码就可以进入到某个产品介绍页面，若朋友购买，分享顾客可获得佣金等。

但是最近日子腾讯产生太阳码的API有不稳定的情况出现，会出现请求超时等问题。正常请求只有85%左右，影响顾客体验。

- **_问题难点：_**

我们无法要求腾讯为我们确保API的性能和成功率，对腾讯API有强依赖。

- **_解决方案：_**

将太阳码预先产生，并保存到我们自身的太阳码库中（由JOB定时产生），预先产生的太阳码包含一个无业务意义的参数（例如太阳码ID，ID是自增长无重复的），顾客产生太阳码时，再把业务参数（顾客编号、顾客选择的产品等）关联到太阳码ID中，并保持到redis中。待顾客扫描太阳码跳转到我们系统时，我们再从redis中依据太阳码ID从redis中查出对应的业务参数（顾客编号、顾客选择的产品等），并执行后续渲染。产生太阳码的成功率从85%提升到100%。

### 2\. 库存中心的统一写操作模型

- **_问题描述_**

库存中心接受两类型的订单，一种是面对toC的订单（最终顾客，C端），由电商系统的交易中心发起；一种是toB端的订单（例如仓库之间转运、工厂到库存之间转运、库存调整等），由AS400发起。在库存中心中针对这两类订单有不同的写操作模型，对于toC订单，库存中心接到订单请求后，先扣减redis，然后再发送MQ，异步落库到DB；对于toB订单，库存中心接到订单请求后，扣减redis再扣减DB（事务确保两者同时成功或同时失败）。

实际这里会有一个比较隐蔽的问题，假设某仓库初始状态有100件库存（redis=100，DB=100），首先接收到来自AS400的toB订单，toB订单让仓库转出100件库存到其他仓库，然后接收到来自于交易中心的toC订单，toC订单中顾客购买5件商品。若处理正常，后者（toC订单）应该不能成立，因为toB订单已经把原有100件库存扣减到0。

但是在DB升降配阶段，DB可能处于不可用状态，库存中心先处理toB订单，但是由于DB不可用，由于事务一致性要求，导致redis扣减也不能成功。toB订单处理不成功后，库存中心暂时将toB订单放置一边（例如放入重试队列，或问题数据表，等待重试），此时由于redis没有扣减成功，可以看作库存是虚高了（虚高100件），而后从交易中心过来的订单则能购买成功，与期望值相反。

- **_问题难点_**

问题较隐蔽，较少发生，较难发现。

- **_解决方案_**

统一一套写模型，无论是toB订单还是toC订单，都统一一套写操作模型。无论是按toB或toC的扣减方案都可以解决此问题，由于扣减模型统一了，扣减前检查的数据源也就统一了。

### 3\. 购物车加载速度优化

- **_问题描述_**

在A公司，顾客可代人购货，例如顾客A帮自己买东西的同时，还可以帮顾客B买东西、帮顾客C买东西，存在多架购物车，而每架购物车中又包含了顾客加购的多个商品，若某顾客下帮了许多顾客购买（例如50人或以上），页面加载就会很慢，或甚至超时返回。

- **_问题难点_**

在加载购物车前要做许多计算，例如商品有效性计算、库存是否足够校验、促销计算、限购配售计算等。涉及调用多个微服务。

- **_解决方案_**

梳理购物车加载计算步骤的依赖性，将没有依赖性的步骤考虑可并行计算，通过统一事务编排框架中的并行执行能力，将多个步骤安排到一起执行。

### 4\.库存中心可销售数量 比 实物少，导致有货不可卖问题

- **_问题描述_**

库存中心为追求高性能，设计了redis和db两个库存的数据源，针对ABO订单，库存中心直接依赖的数据源是redis，例如查询库存是否足够下单是依赖redis，库存扣减也是依赖redis。若发生扣减等场景，会先扣减redis，再异步落库到db。

- 出货场景（导致有货不能卖）：

1) AS400可售库存：1000，库存中心可售库存：1000

2) 扣减库存数100

3) AS400可售库存变更为：900，

4) 调用库存中心出货接口前，库存中心数据：暂扣数-100 ，实物数：1000

5) 调用库存中心出货后的数据：暂扣数+100，实物：-100

6) 第五步执行不成功，所以导致库存中心可售实物数没变化：1000

7) 每天晚上，AS400的库存数量 会与 库存中心的库存数量进行对比（AS400的DB 与 库存中心DB比），若有差异会以AS400的数量为准，对库存中心的数据进行差量抹平。如上例，如果发现库存中心实物数 1000大于as400的900，会将库存中心的实物数变为900    （先更新库存中心db的实物数-100，再更新缓存数据的可销售库存 -100 ）   ，导致库存中心原来准确的redis数量减少了100。最终，库存可卖数量（redis）比实际货量少了。

- 下单未支付场景（导致超卖）：

1）交易中心调用库存中心锁定接口，锁定100

2）库存中心在redis层扣减了库存总量，异步处理数据库的暂扣-100，

3）因为异步处理失败，导致db暂扣数没有-100，在对账的时候会发现库存中心的暂扣数    量比交易中心的大，会有超卖的风险，需要补平这部分数据.

- **_解决方案_**

1）异步落库DB的失败补救处理机制要建立。例如处理失败后，要重试，重试时间

2）统一写模型和读模型。当前对ABO订单，在扣减、出货等写场景，是先扣减redis数量，再异步落DB。而在AS